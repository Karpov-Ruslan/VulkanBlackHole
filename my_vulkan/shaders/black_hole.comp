#version 460

#include "black_hole.in"

// Black Hole params
// Black hole center is (0.0, 0.0, 0.0)
const float BLACK_HOLE_RADIUS = 0.05F; // Schwarzschild radius
const float INV_BLACK_HOLE_RADIUS = 1.0F/BLACK_HOLE_RADIUS;
const float INNER_RADIUS_OF_ACCRETION_DISK = 3.0F*BLACK_HOLE_RADIUS;
const float OUTER_RADIUS_OF_ACCRETION_DISK = 6.0F*BLACK_HOLE_RADIUS;
const vec3 ROTATION_AXIS_OF_ACCRETION_DISK = normalize(vec3(0.0F, 0.0F, 4.0F));
const vec3 COLOR_OF_ACCRETION_DISK = vec3(1.0F, 0.5F, 0.0F) * BLACK_HOLE_RADIUS;
const float THICKNESS_OF_ACCRETION_DISK = 0.01F;
const float INV_THICKNESS_OF_ACCRETION_DISK = 1.0F / THICKNESS_OF_ACCRETION_DISK;

// Ray Marching params
const float STOP_INV_RADIUS_ITER = INV_BLACK_HOLE_RADIUS * 0.01F;
const float TAN_STOP_ITER = 0.001F;
const uint MAX_STEPS = 10000U;
const float h = 0.003F;

// Camera params
const float HALF_FOV_HORIZONTAL_TAN = tan(radians(60));

layout(local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = 1U) in;

layout(set = 0, binding = BINDING_FINAL_IMAGE, rgba8) uniform restrict writeonly image2D outImage;
layout(set = 0, binding = BINDING_CUBE_MAP) uniform samplerCube spaceCubeMap;

layout(push_constant) uniform PushConst {
    layout(offset = PUSH_CONSTANT_CAMERA_POSITION_OFFSET)  vec3 cameraPos;
    layout(offset = PUSH_CONSTANT_CAMERA_DIRECTION_OFFSET) vec3 cameraDir;
};

// Give cameraDir for each pixel
vec3 initializeStartGrid() {
    vec2 resolution = vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);

    vec2 uv = (vec2(gl_GlobalInvocationID.xy) + 0.5F)/resolution;
    vec2 xy = fma(uv, vec2(2.0F), vec2(-1.0F));

    const float horizontalScale = HALF_FOV_HORIZONTAL_TAN;
    float verticalScale = (resolution.y/resolution.x)*HALF_FOV_HORIZONTAL_TAN;

    vec3 horizontalCameraVec = horizontalScale*normalize(vec3(cameraDir.y, -cameraDir.x, 0.0));
    vec3 verticalCameraVec = verticalScale*normalize(cross(cameraDir, horizontalCameraVec));

    return cameraDir + horizontalCameraVec*xy.x + verticalCameraVec*xy.y;
}

float rand(float n){
    return fract(sin(n) * 43758.5453123F);
}

float noise(float p){
	float fl = floor(p);
    float fc = fract(p);
	return mix(rand(fl), rand(fl + 1.0F), fc);
}

float limitRadius(float x, float lo, float hi) {
    return step(lo, x) * step(-hi, -x);
}

float accretionDiskDensity(vec3 position) {
    float a = -dot(position, ROTATION_AXIS_OF_ACCRETION_DISK);
    float r = length(position + a*ROTATION_AXIS_OF_ACCRETION_DISK);
    return max(noise(r*400.0F)*limitRadius(r, INNER_RADIUS_OF_ACCRETION_DISK, OUTER_RADIUS_OF_ACCRETION_DISK) - abs(a)*INV_THICKNESS_OF_ACCRETION_DISK, 0.0F);
}

// u = 1/r; r - radius
// uInfo = vec2(u, d(u)/d(phi));
void transformUInfoIntoDirectionAndPosition(vec2 uInfo, float phi, vec3 rotationAxis, out vec3 position, out vec3 direction) {
    vec3 normCameraPos = normalize(cameraPos);
    vec3 normRotationAxis = normalize(rotationAxis);
    vec3 normPerpendicular = cross(normRotationAxis, normCameraPos); // Normalized Perpendicular
    vec3 normPosition = normCameraPos * cos(phi) + normPerpendicular * sin(phi);
    float radius = (1.0F/uInfo.x);
    position = normPosition*radius;
    direction = normalize(cross(normRotationAxis, normPosition) - normPosition*uInfo.y*radius);
}

// u = 1/r; r - radius
// uInfo = vec2(u, d(u)/d(phi));
vec2 f(vec2 uInfo) {
    return vec2(uInfo.y, 1.5F*BLACK_HOLE_RADIUS*uInfo.x*uInfo.x - uInfo.x);
}

// Explicit Runge-Kutta method (RK4)
// u = 1/r; r - radius
// uInfo = vec2(u, d(u)/d(phi));
vec2 rk4(vec2 uInfo, float h) {
    vec2 k1 = f(uInfo);
    vec2 k2 = f(uInfo + k1*h*0.5F);
    vec2 k3 = f(uInfo + k2*h*0.5F);
    vec2 k4 = f(uInfo + k3*h);
    return uInfo + 0.166666666666666666667F*h*(k1 + 2.0F*k2 + 2.0F*k3 + k4);
}

vec3 traceRayBlackHole(vec3 pixelCameraDir) {
    // u = 1/r; r - radius
    // uInfo = vec2(u, d(u)/d(phi));
    float invInitialRadius = 1.0F/length(cameraPos);
    vec3 rotationAxis = cross(cameraPos, pixelCameraDir);
    vec2 uInfo = vec2(invInitialRadius, -(dot(cameraPos, pixelCameraDir)/length(rotationAxis))*invInitialRadius);
    float phi = 0.0F;

    // Forward declaration
    vec3 direction;
    vec3 position;
    vec3 outputColor = vec3(0.0F);

    for (uint i = 0U; i < MAX_STEPS; ++i) {
        uInfo = rk4(uInfo, h);
        phi += h;

        // Case: Fall into black hole
        if (uInfo.x > INV_BLACK_HOLE_RADIUS) {
            return outputColor;
        }

        // Case: The ray is far away from the black hole, so can stop the cycle.
        if (uInfo.y < TAN_STOP_ITER*INV_BLACK_HOLE_RADIUS && uInfo.x < STOP_INV_RADIUS_ITER) {
            break;
        }

        transformUInfoIntoDirectionAndPosition(uInfo, phi, rotationAxis, position, direction);
        outputColor += accretionDiskDensity(position)*COLOR_OF_ACCRETION_DISK;
    }

    // Case: Go into infinity
    transformUInfoIntoDirectionAndPosition(uInfo, phi, rotationAxis, position, direction);
    outputColor += texture(spaceCubeMap, direction).xyz;
    return outputColor;
}

void main() {
    vec3 pixelCameraDir = initializeStartGrid();
    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(traceRayBlackHole(pixelCameraDir), 1.0F));
}